
# Perceptron Algorithm Code# CS 545 Machine Learning Assignment - 1# Submitted By: Palak Goel# Dated : April 17, 2017
######################################################################################################################################### Libraries used such as numpy for many easy calculations, sklearn for calculating accuracy, random for generating random weights and  ## matplotlib for plotting graphs.                                                                                                      #########################################################################################################################################
import numpy as np
import sklearn from sklearn.metrics import *
import matplotlib.pyplot as pltimport osimport random
########################################################################################################################################### Global variables which are total inputs, total outputs, size of training dataset, size of testing dataset, total epoches and a list    # # of learning rates.                                                                                                                     ###########################################################################################################################################
inputs = 785
outputs = 10
train_size = 60000
test_size = 10000
total_epoch = 50plot=0
learning_rates = [0.1,0.01,0.001]########################################################################################################################################### Loading the dataset from CSV file.                                                                                                     ## First column from the file is taken as labels which are the target values.                                                             ## Rest of the data is taken as dataset for perceptron. This data contains different values till 255. Therefore, scaled by dividing by 255###########################################################################################################################################def file_load(filename):	data = np.loadtxt(filename, delimiter=',')	dataset = np.insert(data[:, np.arange(1, inputs)]/255, 0, 1, axis=1)	labels = data[:, 0]	return dataset, labels	######################################################################################################################################### Training and Testing Perceptron by reading data from CSV files                                                                       #########################################################################################################################################print("Training Perceptron.....\n")train_data, train_labels = file_load('mnist_train.csv')print("Testing Perceptron......\n")test_data, test_labels = file_load('mnist_test.csv')########################################################################################################################################### Calculate the dot product of each input with its random weight generated to give an output array                                       ###########################################################################################################################################def dot_product(data):	output_array = np.dot(np.reshape(data, (1, inputs)), weights)						return output_array############################################################################################################################################# Calculates and returns the error by comparing target and output. If their difference is 0 i.e. matched, no weight update is required else# #weight is updated. Max value from output array is selected. 	                                                                           ############################################################################################################################################# def error_calculation(output_array, predicted):	y = np.insert(np.zeros((1, outputs-1)), np.argmax(output_array), 1)					t = np.insert(np.zeros((1, outputs-1)), predicted, 1)						return t-y############################################################################################################################################# Weights are updated and returned using perceptron learning algorithm. Delta weights are calculated by learing_rate * error * input       ## Updated weights are adding the delta weight in the original weights.                                                                     #############################################################################################################################################                                                     def update_weights(error, data, weights):	delta = np.dot(np.reshape(data, (inputs, 1)), np.reshape(error, (1, outputs)))	weights += (lr * delta)		# Updated weights	return weights############################################################################################################################################# Perceptron is trained by feeding the input, calculating the output , checking the error  and then updating the weights for each input of ## training dataset.                                                                                                                        #############################################################################################################################################def training_perceptron(weights):	for i in range(0, train_size):		output_array = dot_product(train_data[i, :])				        # Feed-forward an image sample to get output array		error = error_calculation(output_array, int(train_labels[i]))		# Evaluate to find array representation of predicted output		weights = update_weights(error, train_data[i, :], weights)		    # Back propagate error through the network to get adjusted weights	return weights############################################################################################################################################## Checking the testing accuracy by computing the actual outputs with the predicted outputs                                                  ############################################################################################################################################## def testing_perceptron(dataset, labels, size):	correct_output = []	for i in range(0, size):		output_array = dot_product(dataset[i, :])				    # Feed-forward an image sample to get output array		correct_output.append(np.argmax(output_array))				# Append the predicted output to correct_output list	return accuracy_score(labels, correct_output), correct_output########################################################################################################################################### For each learning rate perceptron is trained and tested                                                                                ###########################################################################################################################################'for lr in learning_rates:
	plot+=1
	# Randomize Weights are generated in the range of (-0.05,0.05)
	weights = (np.random.rand(inputs, outputs) - 0.5)*(0.1)				
	# for each epoch:	
	previous_accuracy = 1
	epoch = 0
	testacc_array = [ ]
	trainacc_array = [ ]
	while (1):        # Accuracy is calculated on training dataset
		current_accuracy, correct_output = testing_perceptron(train_data, train_labels, train_size)			
		print("Epoch " + str(epoch) + " :\nTraining Accuracy = " + str(current_accuracy))
		trainacc_array.append(current_accuracy)  # Array is maintained to plot the graph
		if epoch==total_epoch:
			break									        # Accuracy is calculated on test dataset
		test_accu, correct_output = testing_perceptron(test_data, test_labels, test_size)					print("Test Accuracy = " + str(test_accu))		print("\n")
		previous_accuracy = current_accuracy
		epoch+=1
		i=0
		testacc_array.append(test_accu)  # Array is maintained to plot the graph
		weights = training_perceptron(weights)		# Train the network       # Testing the network on test set again , calculating testing accuracy                                                               
	test_accu, correct_output = testing_perceptron(test_data, test_labels, test_size)				
	print("Test Accuracy = " + str(test_accu) + "\n\nLearning Rate = " + str(lr) + "\n\nConfusion Matrix :\n")
	print(confusion_matrix(test_labels, correct_output)) #calculating confusion matrix depicting how many correct output is classified for the testing data                                               	print("\n")	      # Plotting the graph of training and testing accuracies against epoch:
	print("plot: ",plot)	plt.figure(plot)	plt.title("Learning Rate: %s" %lr)	plt.plot(testacc_array)	plt.plot(trainacc_array)	plt.ylabel("Accuracy %")	plt.xlabel("Epoch")
plt.show()
